# 201930119 윤덕규

## 9월 11일 강의
### Transpile
* Babel은 ECMAScript와 같은 자바스크립트 최신 버전이나, TypeScript를 이전 버전의 코드로 변환시켜 주는 Transpile 도구
* 개발자가 작성한 코드 -> Parse -> Transform -> Generate -> 이전 버전의 코드
* SWC(Speedy Web Compiler)도 Babel과 같은 자바스크립트 트랜스 컴파일러
* SWC는 Rust로 작성되어 있어 Babel에 비해 속도가 훨씬 빠름

### Babel의 단점
* Babel로 변환된 코드를 이해하기 어려움
* 원 코드에 비해 변환 코드의 길이가 늘어남
* 변환에 시간이 오래 걸림

### SWC의 장점
* Next.js에 내장되어 있어 별도의 설정 없이 사용 가능

### 렌더링 전략
* 웹 페이지 또는 웹 애플리케이션을 웹 브라우저에 제공하는 방법
* 정적인 페이지 제작에는 Gatsby
* Next.js에서는 어떤 페이지는 빌드 시점에 정적으로 생성하고, 어떤 페이지는 실행 시점에 동적으로 생성할지 쉽게 정할 수 있음
* 특정 페이지에 대한 요청이 있을 때마다 페이지를 다시 생성 가능
* 반드시 클라이언트에서 렌더링해야 할 컴포넌트도 지정할 수 있어서 개발이 쉬움

### 서버 사이드 렌더링(SSR)
* 웹 페이지를 제공하는 가장 흔한 방법
* APM을 이용하는 일반적인 웹 페이지 생성 방법
* 자바스크립트 코드가 적재되면 동적으로 페이지 내용 렌더링
* Next.js도 동적으로 페이지 렌더링 가능
* 스크립트 코드를 집어 넣어서 나중에 웹 페이지를 동적으로 처리하는 것 = 하이드레이션
* 서버 사이드 렌더링 -> 자바스크립트가 하이드레이션 된 페이지를 전송 -> 클라이언트에서 DOM 위에 각 스크립트 코드를 하이드레이션 : 페이지 새로 고침 없이 사용자와 웹 페이지 간 상호 작용을 가능하게 함

### SSR의 장점
* 더 안전한 웹 애플리케이션 : 쿠키 관리, 주요 API, 데이터 검증 등과 같은 작업을 서버에서 처리하기 때문에 중요한 데이터를 클라이언트에 노출할 필요 없음
* 더 뛰어난 웹 사이트 호환성 : 클라이언트 환경이 자바스크립트를 사용하지 못하거나 오래된 브라우저를 사용하더라도 서비스를 제공할 수 있음
* 더 뛰어난 SEO : 서버가 렌더링할 HTML을 받기 때문에 봇이나 웹 크롤러가 페이지를 렌더링할 필요 없음

### 클라이언트 사이드 렌더링(CSR)
* React 앱을 실행하면 렌더링 시작 전에 빈 화면이 한동안 유지되는 것이 보임
* 이는 서버에서 스크립트와 스타일만 포함된 HTML을 전송하기 때문
* 실제 렌더링은 클라이언트에서 이루어짐
* CSR로 생성한 앱의 HTML을 보면 div 태그 하나밖에 없음
* 빌드 과정에서 js와 css 파일을 HTML 페이지에 불러오도록 만들고 root div에 렌더링

### CSR의 장점
* 네이티브 앱처럼 느껴지는 웹 앱 : 전체 자바스크립트 번들을 다운로드 한다는 것은 렌더링할 모든 페이지가 이미 브라우저에 다운로드 되어 있다는 뜻
* 쉬운 페이지 전환 : 클라이언트에서의 내비게이션은 브라우저 화면을 새로 고칠 필요 없이 다른 페이지로의 이동을 가능하게 함
* 지연된 로딩과 성능 : 웹 앱은 최소로 필요한 HTML만 렌더링, 버튼을 누르면 나오는 모달도 실제 버튼이 눌렸을 때 동적으로 생성
* 서버 부하 감소 : 서버리스 환경에서 웹 앱을 제공 가능

### 정적 사이트 생성(SSG)
* 일부 또는 전체 페이지를 빌드 시점에 미리 렌더링

### SSG의 장점
* 쉬운 확장 : 정적 페이지는 단순 HTML 파일이므로 CDN을 통해 파일을 제공하거나 캐시에 저장하기 쉬움
* 뛰어난 성능 : 빌딋 점에 HTML 페이지를 미리 렌더링하기 때문에 페이지를 요청해도 클라이언트나 서버가 무언가를 처리할 필요가 없음
* 더 안전한 API 요청 : 외부 API를 호출하거나, 데이터베이스에 접근하거나, 보호해야 할 데이터에 접근할 일이 없음  
-> 필요한 모든 정보가 빌드 시점에 미리 페이지로 렌더링 되어 있기 때문

## 9월 4일 강의
### 프로젝트의 기본 구조
* Next.js는 네비게이션을 구현할 때 react-router와 같은 라이브러리를 사용하지 않고, pages/디렉토리 사용
* Next13.4 후반부터 pages가 app으로 변경
* pages/ 디렉토리 안의 모든 js 파일은 public 페이지가 됨
* public/ 디렉토리에는 웹 사이트의 모든 퍼블릭 페이지와 정적 콘텐츠가 있음
* 용도가 정해진 디렉토리는 pages와 public 2가지
* 나머지 디렉토리는 필요에 따라서 다른 목적으로 사용하거나 삭제 가능  
-> 프로젝트 root에 필요한 디렉토리를 새로 생성해서 사용 가능

## 8월 28일 강의
### Next.js
* 리액트를 위해 만든 오픈소스 자바스크립트 웹 프레임워크
* 리액트에는 없는 다양한 기능 제공  
-> 서버 사이드 렌더링(SSR : Server Side Rendering)  
-> 정적 사이트 생성(SSG : Static Site Generation)  
-> 증분 정적 재생성(ISR : Incremental Static Regeneration)
* SSG는 미리 만들어 놓은 페이지를 서비스해서 속도는 빠르지만 수정 불가
* ISR은 이미 생성된 페이지를 일정 시간이 지난 후 다시 생성(최신 데이터로 업데이트)

### Next.js와 비슷한 프레임워크
* Gatsby  
-> 정적 웹 사이트를 만들 수 있는 프레임워크  
-> 정적 사이트 생성만 지원  
-> 클라이언트 사이드 렌더링만 지원

* Razzle  
-> 서버 사이드 렌더링이 가능한 자바스크립트 애플리케이션 개발 가능  
-> CRA와 유사하게 프로젝트를 구성할 수 있다는 장점(create-razzle-app)  
-> React, Preact, Reason-React, Angular 및 Vue와 함께 사용 가능

* Nuxt.js  
-> Vue를 사용한 웹 애플리케이션 개발에서 리액트의 Next.js에 해당하는 프레임워크  
-> Nuxt.js나 Next.js 모두 같은 목표를 갖지만 Nuxt.js는 더 많은 설정 필요

* Angular Universal  
-> 정적 사이트 생성과 서버 사이드 렌더링 지원  
-> Nuxt나 Next와는 달리 구글에서 만듬